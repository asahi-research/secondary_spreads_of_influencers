#!/usr/bin/env python3

import argparse
import os
import polars as pl


arg_parser = argparse.ArgumentParser()
arg_parser.add_argument("--n", type=int, required=True)
arg_parser.add_argument("--offset", type=int, required=True)
arg_parser.add_argument("--userinfo_path", type=str, required=True)
arg_parser.add_argument("--retweeted_tweets_dir", type=str, required=True)
arg_parser.add_argument("--exclude_qt", action="store_true")
arg_parser.add_argument("--qt_ids_path", type=str, required=False)
arg_parser.add_argument("--exploded_rt_cascades_path", type=str, required=True)
arg_parser.add_argument("--follower_relations_path", type=str, required=True)
arg_parser.add_argument("--rt_timestamps_path", type=str, required=False)
arg_parser.add_argument("--filter_by_timestamps", action="store_true")
arg_parser.add_argument("--save_dir", type=str, required=True)


# [File Summary]
# This script computes the second spreaders.
# [Configs]
# n:
#   Number of second spreaders to compute.
#   The number of rows is Num of Second Spraders * Num of spreaders' followers.
#   In other words, it consumes a huge amount of memory, so to avoid this,
#   the number of users to be calculated is controlled.
# offset:
#   The offset of the user to be calculated.
#   If n=1000 and offset=1000, the 1000th to 2000th users are calculated.
# exclude_qt:
#   If True, exclude quoted tweets from the analysis.
# filter_by_timestamps:
#   If True, filter the follower relations by timestamps.
# [Inputs]
# userinfo_path:
#   Path to the user bio information file.
# retweeted_tweets_dir:
#   Directory path where the retweeted tweets are stored.
#   This files outputed by format_retweeted_data.py.
# qt_ids_path:
#   Path to the quoted tweet ids.
#   exracted by extract_qt_ids.py.
# exploded_rt_cascades_path:
#   Path to the exploded retweet cascades.
#   The transformed retweet cascades are generated by explode_rt_cascades.py.
# follower_relations_path:
#   Path to the follower relations.
#   This file is generated by build_follower_relations_data.py.
# rt_timestamps_path:
#   Path to the retweet timestamps.
#   Ths file is generated by extract_rt_timestamps.py.
# [Outputs]
# save_dir:
#   Directory to save the computed second spreaders.


def main(args):
    print("Loading User Information...")

    df_userinfo = pl.read_parquet(args.userinfo_path)
    user_ids = df_userinfo["user_id"].sort(descending=True).to_list()
    print(f"Number of Users: {len(user_ids)}")
    target_user_ids = user_ids[args.offset: args.offset + args.n]
    print(f"Number of Target Users: {len(target_user_ids)}")

    df_pc_nodes = pl.read_parquet(args.exploded_rt_cascades_path)

    print("Loading retweeted tweets...")
    retweeted_tweets_files = os.listdir(args.retweeted_tweets_dir)
    retweeted_tweets_paths = [os.path.join(args.retweeted_tweets_dir, f)
                              for f in retweeted_tweets_files]

    df_list = []
    for i, path in enumerate(retweeted_tweets_paths):
        df_rt = pl.read_parquet(path)
        df_list.append(df_rt)
    df_rt = pl.concat(df_list)
    del df_list
    df_rt = df_rt.filter(df_rt["user_id"].is_not_null())
    df_rt = df_rt[["source_tweet_id", "user_id", "tweet_id"]]
    df_rt = df_rt.filter(df_rt["source_tweet_id"].is_not_null())

    if args.rt_timestamps_path:
        df_rt_timestamps = pl.read_parquet(args.rt_timestamps_path)
        df_rt = df_rt.join(
            df_rt_timestamps,
            left_on="tweet_id",
            right_on="tweet_id",
            how="inner"
        )

    if args.exclude_qt:
        if not args.qt_ids_path:
            raise ValueError("qt_ids_path is required when exclude_qt is True")
        df_qt_ids = pl.read_parquet(args.qt_ids_path)
        df_rt = df_rt.filter(~df_rt["source_tweet_id"].is_in(df_qt_ids["tweet_id"]))

    print("Grouping by user_id...")
    df_user_retweets = df_rt.group_by("user_id").agg(
        pl.col("tweet_id"),
        pl.col("source_tweet_id"),
    )

    print("Loading follower relations...")
    df_follower_relations = pl.read_parquet(args.follower_relations_path)

    retweeted_user_ids = df_rt["user_id"].unique().to_list()

    print(f"Number of retweeted users: {len(retweeted_user_ids)}")
    print(f"Number of followees: {df_follower_relations['followee'].n_unique()}")
    print(f"Number of followers: {df_follower_relations['follower'].n_unique()}")
    print(f"Number of followers: {len(df_follower_relations['follower'].unique())}")

    # RTを1回以上しているユーザのみを対象にする
    df_follower_relations = df_follower_relations.filter(
        df_follower_relations["followee"].is_in(retweeted_user_ids))
    print(f"Number of followees: {df_follower_relations['followee'].n_unique()}")
    # 休眠アカウントやRTをしないアカウントを除外
    df_follower_relations = df_follower_relations.filter(
        df_follower_relations["follower"].is_in(retweeted_user_ids))
    print(f"Number of followees: {df_follower_relations['followee'].n_unique()}")
    print(f"Number of followers: {df_follower_relations['follower'].n_unique()}")
    del retweeted_user_ids

    # カスケードに現れるアカウントのみをfolloweeの対象とする
    # カスケードに現れないとSecond Spreadの親が存在しないため
    # parent_ids = df_pc_nodes["parent"].unique().to_list()
    # child_ids = df_pc_nodes["child"].unique().to_list()
    # df_follower_relations = df_follower_relations.filter(
    #     df_follower_relations["followee"].is_in(set(parent_ids + child_ids)))

    df_follower_relations = df_follower_relations.filter(
        pl.col("followee").is_in(target_user_ids))

    print(f"Number of followees: {df_follower_relations['followee'].n_unique()}")
    print(f"Number of followers: {df_follower_relations['follower'].n_unique()}")

    print("Joining retweet information...")
    df_follower_relations = df_follower_relations.join(
        df_user_retweets, left_on="followee", right_on="user_id", how="inner"
    )
    del df_user_retweets
    print(f"Number of followees: {df_follower_relations['followee'].n_unique()}")
    print(f"Number of followers: {df_follower_relations['follower'].n_unique()}")

    print("Exploding retweets...")
    df_follower_relations = df_follower_relations.explode(
        ["tweet_id", "source_tweet_id"])

    print("Joining parent-child relations...")
    # カスケードでRTされなかったものを補完
    # 正しいパスだけ残すってことはできているだろうか
    # 例えば、あるsource_tweetについて、prentとchildのパスは原則1つだけ
    df_follower_relations = df_follower_relations.join(
        df_pc_nodes,
        left_on=["source_tweet_id", "followee", "follower", "tweet_id"],
        right_on=["source_tweet_id", "parent", "child", "parent_tweet_id"],
        how="left").rename({"tweet_id": "parent_tweet_id"})
    print(f"Number of followees: {df_follower_relations['followee'].n_unique()}")
    print(f"Number of followers: {df_follower_relations['follower'].n_unique()}")

    print("Joining tweet information...")
    rename_dict = {"timestamp": "followee_timestamp"}
    df_follower_relations = df_follower_relations.join(
        df_rt,
        left_on=["source_tweet_id", "parent_tweet_id", "followee"],
        right_on=["source_tweet_id", "tweet_id", "user_id"],
    ).rename(rename_dict)
    print(f"Number of followees: {df_follower_relations['followee'].n_unique()}")
    print(f"Number of followers: {df_follower_relations['follower'].n_unique()}")

    df_follower_relations = df_follower_relations.join(
        df_rt[["source_tweet_id", "tweet_id", "user_id", "timestamp"]],
        left_on=["source_tweet_id", "child_tweet_id", "follower"],
        right_on=["source_tweet_id", "tweet_id", "user_id"],
        how="left"
    ).rename({"timestamp": "follower_timestamp"})
    print(f"Number of followees: {df_follower_relations['followee'].n_unique()}")
    print(f"Number of followers: {df_follower_relations['follower'].n_unique()}")

    df_follower_relations = df_follower_relations.with_columns(
        df_follower_relations["child_tweet_id"].is_not_null().alias("is_retweeted"))

    is_in_cascade_tweets = df_pc_nodes["source_tweet_id"].unique().to_list()
    df_follower_relations = df_follower_relations.with_columns(
        pl.col("source_tweet_id").is_in(is_in_cascade_tweets).alias("is_in_cascade"))

    if args.filter_by_timestamps:
        if not args.rt_timestamps_path:
            raise ValueError("rt_timestamps_path is required when filter_by_timestamps is True")
        df_follower_relations = df_follower_relations.with_columns(
            pl.col("follower_timestamp").fill_null(float("inf")))
        df_follower_relations = df_follower_relations.filter(
            pl.col("follower_timestamp") > pl.col("followee_timestamp"))
    print(f"Number of followees: {df_follower_relations['followee'].n_unique()}")
    print(f"Number of followers: {df_follower_relations['follower'].n_unique()}")

    print("Writing data...")
    df_follower_relations.write_parquet(f"{args.save_dir}/{args.offset}_to_{args.offset + args.n}.parquet")


if __name__ == "__main__":
    args = arg_parser.parse_args()
    main(args)
