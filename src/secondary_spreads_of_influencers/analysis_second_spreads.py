#!/usr/bin/env python3

import os
import argparse
import polars as pl


arg_parser = argparse.ArgumentParser()
arg_parser.add_argument("--retweet_count_path", type=str, required=True)
arg_parser.add_argument("--aggregated_virtual_timeline", type=str, required=True)
arg_parser.add_argument("--user_influence_score_path", type=str, required=True)
arg_parser.add_argument("--influence_column_name", type=str, default="hg-index")
arg_parser.add_argument("--is_in_cascade", action="store_true")
arg_parser.add_argument("--exclude_official", action="store_true")
arg_parser.add_argument("--min_rt", type=int, default=0)
arg_parser.add_argument("--save_path", type=str, required=True)


# [File Summary]
# This script computes the second spread ratio of the users.
# [Configs]
# min_rt:
#   Minimum number of retweets in the cascade.
# max_rt:
#   Maximum number of retweets in the cascade.
# is_in_cascade:
#   If True, only the parent retweets in the cascade are considered.
# exclude_official:
#   If True, exclude the official accounts from the analysis.
#   The official accounts are the accounts that have the verified badge.
# influence_column_name:
#   The column name of the influence score.
# [Inputs]
# retweet_count_path:
#   Path to the retweet count.
#   This file is generated by compute_retweet_counts.py.
# aggregated_second_sperads:
#   Path to the aggregated second spreads.
#   This file is generated by aggregate_second_spreads.py.
# user_influence_score_path:
#   Path to the user influence score.
#   This file is generated by compute_h_index.py or compute_centrality_from_retweets.py.
# [Outputs]
# save_path:
#   Path to save the computed second spread ratio.


def main(args):
    print("Loading retweeted tweets...")
    df_rt = pl.read_parquet(args.retweet_count_path)
    df_rt = df_rt.filter(pl.col("num_retweets") > args.min_rt)

    target_source_tweet_ids = df_rt["source_tweet_id"].to_list()

    print("Loading Second Spreads...")
    df_ss = pl.read_parquet(args.aggregated_virtual_timeline)

    if args.is_in_cascade:
        # If is_in_cascade is True, only include the second spreaders in the cascade.
        # If the path of a retweet is unknown, it is not considered in the analysis, even if it was retweeted.
        # This is because there would be no subsequent cascade beyond that user, making it impossible to analyze how the information spreads further.
        # This limitation stems from our methodology for constructing repost cascades.
        df_ss = df_ss.filter(pl.col("is_in_cascade"))

    if args.exclude_official:
        df_ss = df_ss.filter(~pl.col("is_official"))

    df_ss = df_ss.filter(pl.col("source_tweet_id").is_in(target_source_tweet_ids))

    df_user_influence = pl.read_parquet(args.user_influence_score_path)
    df_user_influence = df_user_influence.with_columns(
        pl.col(args.influence_column_name).rank("min").alias("rank"))
    df_user_influence = df_user_influence.with_columns(
        pl.col(args.influence_column_name).qcut(
            [0.5, 0.7, 0.9, 0.95, 0.99],
            labels=["low", "low-mid", "mid", "high-mid", "high", "very-high"],
            allow_duplicates=True,
        ).alias("influence_score_group"))

    df_ss = df_ss.join(
        df_user_influence,
        left_on="followee",
        right_on="user_id",
        coalesce=True)

    df_result = df_ss.group_by("influence_score_group").agg(
        pl.sum("num_views").alias("num_views"),
        pl.sum("num_retweets").alias("num_retweets"),
    ).with_columns(
        (pl.col("num_retweets") / pl.col("num_views")).alias("second_spread_ratio")
    ).sort("influence_score_group", descending=True)

    print("")
    print(df_result)

    df_result.write_excel(args.save_path)


if __name__ == "__main__":
    args = arg_parser.parse_args()
    main(args)
